import numpy as np


# Определение функции f1(x)
def f1(x):
    return x**4 / (26 + x**2)


# Метод прямоугольников для численного интегрирования
def rectangle_method(f, a, b, n):
    h = (b - a) / n  # Шаг разбиения
    result = (
        sum(f(a + i * h) for i in range(n)) * h
    )  # Суммируем значения функции в разбиениях и умножаем на шаг разбиения
    return result


# Метод трапеций для численного интегрирования
def trapezoidal_method(f, a, b, n):
    h = (b - a) / n  # Шаг разбиения
    result = (f(a) + f(b)) / 2 + sum(
        f(a + i * h) for i in range(1, n)
    )  # Суммируем значения функции и учитываем крайние значения
    return result * h  # Умножаем на шаг разбиения


# Метод Симпсона для численного интегрирования
def simpson_method(f, a, b, n):
    if n % 2 == 1:
        n += 1  # Увеличиваем n, если оно нечетное, так как метод Симпсона требует четное количество разбиений
    h = (b - a) / n  # Шаг разбиения
    result = (
        f(a)
        + f(b)
        + 4
        * sum(
            f(a + i * h) for i in range(1, n, 2)
        )  # Учет значений в нечетных разбиениях
        + 2
        * sum(
            f(a + i * h) for i in range(2, n - 1, 2)
        )  # Учет значений в четных разбиениях
    )
    return result * h / 3  # Умножаем на шаг разбиения и делим на 3


# Пределы интегрирования и количество разбиений
a1, b1 = 1, 2
n = 100000

# Вычисление интегралов методами прямоугольников, трапеций и Симпсона
int1_rect = rectangle_method(f1, a1, b1, n)
int1_trap = trapezoidal_method(f1, a1, b1, n)
int1_simp = simpson_method(f1, a1, b1, n)

# Вывод результатов
print(f"Метод прямоугольников: {int1_rect:.7f}")
print(f"Метод трапеций: {int1_trap:.7f}")
print(f"Метод Симпсона: {int1_simp:.7f}")
